Standard library header <cstdlib>
 
C++
 
Standard library headers
 

This header was originally in the C standard library as <stdlib.h>.

This header provides miscellaneous utilities. Symbols defined here are used by several library components.
Types
div_t
	structure type, returned by std::div
(typedef)
ldiv_t
	structure type, returned by std::ldiv
(typedef)
lldiv_t
(C++11)
	structure type, returned by std::lldiv
(typedef)
size_t
	unsigned integer type returned by the sizeof operator
(typedef)
Macro constants
EXIT_SUCCESSEXIT_FAILURE
	indicates program execution status
(macro constant)
MB_CUR_MAX
	maximum number of bytes in a multibyte character with the current locale
(macro constant)
NULL
	implementation-defined null pointer constant
(macro constant)
RAND_MAX
	maximum possible value generated by std::rand
(macro constant)
Functions
Process control
abort
	causes abnormal program termination (without cleaning up)
(function)
exit
	causes normal program termination with cleaning up
(function)
quick_exit
(C++11)
	causes quick program termination without completely cleaning up
(function)
_Exit
(C++11)
	causes normal program termination without cleaning up
(function)
atexit
	registers a function to be called on std::exit() invocation
(function)
at_quick_exit
(C++11)
	registers a function to be called on std::quick_exit invocation
(function)
system
	calls the host environment's command processor
(function)
getenv
	access to the list of environment variables
(function)
Memory management
malloc
	allocates memory
(function)
aligned_alloc
(C++17)
	allocates aligned memory
(function)
calloc
	allocates and zeroes memory
(function)
realloc
	expands or shrinks previously allocated memory block
(function)
free
	deallocates previously allocated memory
(function)
Numeric string conversion
atof
	converts a byte string to a floating point value
(function)
atoiatolatoll
(C++11)
	converts a byte string to an integer value
(function)
strtolstrtoll
(C++11)
	converts a byte string to an integer value
(function)
strtoulstrtoull
(C++11)
	converts a byte string to an unsigned integer value
(function)
strtofstrtodstrtold
	converts a byte string to a floating-point value
(function)
Wide string manipulation
mblen
	returns the number of bytes in the next multibyte character
(function)
mbtowc
	converts the next multibyte character to wide character
(function)
wctomb
	converts a wide character to its multibyte representation
(function)
mbstowcs
	converts a narrow multibyte character string to wide string
(function)
wcstombs
	converts a wide string to narrow multibyte character string
(function)
Miscellaneous algorithms and math
rand
	generates a pseudo-random number
(function)
srand
	seeds pseudo-random number generator
(function)
qsort
	sorts a range of elements with unspecified type
(function)
bsearch
	searches an array for an element of unspecified type
(function)
abs(int)labsllabs
(C++11)
	computes absolute value of an integral value (|x|
)
(function)
div(int)ldivlldiv
(C++11)
	computes quotient and remainder of integer division
(function)
Synopsis

namespace std {
  using size_t =  /* see description */; // freestanding
  using div_t =   /* see description */; // freestanding
  using ldiv_t =  /* see description */; // freestanding
  using lldiv_t = /* see description */; // freestanding
}
 
#define NULL         /* see description */ // freestanding
#define EXIT_FAILURE /* see description */ // freestanding
#define EXIT_SUCCESS /* see description */ // freestanding
#define RAND_MAX     /* see description */
#define MB_CUR_MAX   /* see description */
 
namespace std {
  // Exposition-only function type aliases
  extern "C" using /* c-atexit-handler */ = void(); // exposition only
  extern "C++" using /* atexit-handler */ = void(); // exposition only
  extern "C" using /* c-compare-pred */ =           // exposition only
    int(const void*, const void*);
  extern "C++" using /* compare-pred */ =           // exposition only
    int(const void*, const void*);
 
  // start and termination
  [[noreturn]] void abort() noexcept;                       // freestanding
  int atexit(/* c-atexit-handler */* func) noexcept;        // freestanding
  int atexit(/* atexit-handler */* func) noexcept;          // freestanding
  int at_quick_exit(/* c-atexit-handler */* func) noexcept; // freestanding
  int at_quick_exit(/* atexit-handler */* func) noexcept;   // freestanding
  [[noreturn]] void exit(int status);                       // freestanding
  [[noreturn]] void _Exit(int status) noexcept;             // freestanding
  [[noreturn]] void quick_exit(int status) noexcept;        // freestanding
 
  char* getenv(const char* name);
  int system(const char* string);
 
  // C library memory allocation
  void* aligned_alloc(size_t alignment, size_t size);
  void* calloc(size_t nmemb, size_t size);
  void free(void* ptr);
  void* malloc(size_t size);
  void* realloc(void* ptr, size_t size);
 
  double atof(const char* nptr);
  int atoi(const char* nptr);
  long int atol(const char* nptr);
  long long int atoll(const char* nptr);
  double strtod(const char* nptr, char** endptr);
  float strtof(const char* nptr, char** endptr);
  long double strtold(const char* nptr, char** endptr);
  long int strtol(const char* nptr, char** endptr, int base);
  long long int strtoll(const char* nptr, char** endptr, int base);
  unsigned long int strtoul(const char* nptr, char** endptr, int base);
  unsigned long long int strtoull(const char* nptr, char** endptr, int base);
 
  // multibyte / wide string and character conversion functions
  int mblen(const char* s, size_t n);
  int mbtowc(wchar_t* pwc, const char* s, size_t n);
  int wctomb(char* s, wchar_t wchar);
  size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n);
  size_t wcstombs(char* s, const wchar_t* pwcs, size_t n);
 
  // C standard library algorithms
  void* bsearch(const void* key, const void* base,  // freestanding
                size_t nmemb, size_t size, /* c-compare-pred */* compar);
  void* bsearch(const void* key, const void* base,  // freestanding
                size_t nmemb, size_t size, /* compare-pred */* compar);
  void qsort(void* base, size_t nmemb, size_t size, // freestanding
             /* c-compare-pred */* compar);
  void qsort(void* base, size_t nmemb, size_t size, // freestanding
             /* compare-pred */* compar);
 
  // low-quality random number generation
  int rand();
  void srand(unsigned int seed);
 
  // absolute values
  constexpr int abs(int j);                       // freestanding
  constexpr long int abs(long int j);             // freestanding
  constexpr long long int abs(long long int j);   // freestanding
  constexpr /* floating-point-type */
    abs(/* floating-point-type */ j);             // freestanding-deleted
 
  constexpr long int labs(long int j);            // freestanding
  constexpr long long int llabs(long long int j); // freestanding
 
  constexpr div_t div(int numer, int denom);                         // freestanding
  constexpr ldiv_t div(long int numer, long int denom);              // freestanding
  constexpr lldiv_t div(long long int numer, long long int denom);   // freestanding
  constexpr ldiv_t ldiv(long int numer, long int denom);             // freestanding
  constexpr lldiv_t lldiv(long long int numer, long long int denom); // freestanding
}

Dynamic memory management
 
C++
 
Utilities library
 
Dynamic memory management
 
Smart pointers

Smart pointers enable automatic, exception-safe, object lifetime management.
Defined in header <memory>
Pointer categories
unique_ptr
(C++11)
	smart pointer with unique object ownership semantics
(class template)
shared_ptr
(C++11)
	smart pointer with shared object ownership semantics
(class template)
weak_ptr
(C++11)
	weak reference to an object managed by std::shared_ptr
(class template)
auto_ptr
(deprecated in C++11)(removed in C++17)
	smart pointer with strict object ownership semantics
(class template)
Helper classes
owner_less
(C++11)
	provides mixed-type owner-based ordering of shared and weak pointers
(class template)
owner_hash
(C++26)
	provides owner-based hashing for shared and weak pointers
(class)
owner_equal
(C++26)
	provides mixed-type owner-based equal comparisons of shared and weak pointers
(class)
enable_shared_from_this
(C++11)
	allows an object to create a shared_ptr referring to itself
(class template)
bad_weak_ptr
(C++11)
	exception thrown when accessing a weak_ptr which refers to already destroyed object
(class)
default_delete
(C++11)
	default deleter for unique_ptr
(class template)
Smart pointer adaptors
out_ptr_t
(C++23)
	interoperates with foreign pointer setters and resets a smart pointer on destruction
(class template)
out_ptr
(C++23)
	creates an out_ptr_t with an associated smart pointer and resetting arguments
(function template)
inout_ptr_t
(C++23)
	interoperates with foreign pointer setters, obtains the initial pointer value from a smart pointer, and resets it on destruction
(class template)
inout_ptr
(C++23)
	creates an inout_ptr_t with an associated smart pointer and resetting arguments
(function template)
Allocators

Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.
Defined in header <memory>
allocator
	the default allocator
(class template)
allocator_traits
(C++11)
	provides information about allocator types
(class template)
allocation_result
(C++23)
	records the address and the actual size of storage allocated by allocate_at_least
(class template)
allocator_argallocator_arg_t
(C++11)
	a tag used to select allocator-aware constructors
(tag)
uses_allocator
(C++11)
	checks if the specified type supports uses-allocator construction
(class template)
uses_allocator_construction_args
(C++20)
	prepares the argument list matching the flavor of uses-allocator construction required by the given type
(function template)
make_obj_using_allocator
(C++20)
	creates an object of the given type by means of uses-allocator construction
(function template)
uninitialized_construct_using_allocator
(C++20)
	creates an object of the given type at specified memory location by means of uses-allocator construction
(function template)
Defined in header <scoped_allocator>
scoped_allocator_adaptor
(C++11)
	implements multi-level allocator for multi-level containers
(class template)
Defined in header <memory_resource>
Defined in namespace std::pmr
polymorphic_allocator
(C++17)
	an allocator that supports run-time polymorphism based on the std::pmr::memory_resource it is constructed with
(class template)

Memory resources (since C++17)

Memory resources implement memory allocation strategies that can be used by std::pmr::polymorphic_allocator
Defined in header <memory_resource>
Defined in namespace std::pmr
memory_resource
(C++17)
	an abstract interface for classes that encapsulate memory resources
(class)
new_delete_resource
(C++17)
	returns a static program-wide std::pmr::memory_resource that uses the global operator new and operator delete to allocate and deallocate memory
(function)
null_memory_resource
(C++17)
	returns a static std::pmr::memory_resource that performs no allocation
(function)
get_default_resource
(C++17)
	gets the default std::pmr::memory_resource
(function)
set_default_resource
(C++17)
	sets the default std::pmr::memory_resource
(function)
pool_options
(C++17)
	a set of constructor options for pool resources
(class)
synchronized_pool_resource
(C++17)
	a thread-safe std::pmr::memory_resource for managing allocations in pools of different block sizes
(class)
unsynchronized_pool_resource
(C++17)
	a thread-unsafe std::pmr::memory_resource for managing allocations in pools of different block sizes
(class)
monotonic_buffer_resource
(C++17)
	a special-purpose std::pmr::memory_resource that releases the allocated memory only when the resource is destroyed
(class)
Uninitialized storage

Several utilities are provided to create and access raw storage.
Defined in header <memory>
raw_storage_iterator
(deprecated in C++17)(removed in C++20)
	an iterator that allows standard algorithms to store results in uninitialized memory
(class template)
get_temporary_buffer
(deprecated in C++17)(removed in C++20)
	obtains uninitialized storage
(function template)
return_temporary_buffer
(deprecated in C++17)(removed in C++20)
	frees uninitialized storage
(function template)
Uninitialized memory algorithms
Defined in header <memory>
uninitialized_copy
	copies a range of objects to an uninitialized area of memory
(function template)
uninitialized_copy_n
(C++11)
	copies a number of objects to an uninitialized area of memory
(function template)
uninitialized_fill
	copies an object to an uninitialized area of memory, defined by a range
(function template)
uninitialized_fill_n
	copies an object to an uninitialized area of memory, defined by a start and a count
(function template)
uninitialized_move
(C++17)
	moves a range of objects to an uninitialized area of memory
(function template)
uninitialized_move_n
(C++17)
	moves a number of objects to an uninitialized area of memory
(function template)
uninitialized_default_construct
(C++17)
	constructs objects by default-initialization in an uninitialized area of memory, defined by a range
(function template)
uninitialized_default_construct_n
(C++17)
	constructs objects by default-initialization in an uninitialized area of memory, defined by a start and a count
(function template)
uninitialized_value_construct
(C++17)
	constructs objects by value-initialization in an uninitialized area of memory, defined by a range
(function template)
uninitialized_value_construct_n
(C++17)
	constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count
(function template)
destroy_at
(C++17)
	destroys an object at a given address
(function template)
destroy
(C++17)
	destroys a range of objects
(function template)
destroy_n
(C++17)
	destroys a number of objects in a range
(function template)
construct_at
(C++20)
	creates an object at a given address
(function template)
Constrained uninitialized memory algorithms (since C++20)

C++20 provides constrained uninitialized memory algorithms that accept range arguments or iterator-sentinel pairs.
Defined in header <memory>
Defined in namespace std::ranges
no-throw-input-iteratorno-throw-forward-iteratorno-throw-sentinel-forno-throw-input-rangeno-throw-forward-range
(C++20)
	specifies some operations on iterators, sentinels and ranges are non-throwing
(exposition-only concept*)
ranges::uninitialized_copy
(C++20)
	copies a range of objects to an uninitialized area of memory
(niebloid)
ranges::uninitialized_copy_n
(C++20)
	copies a number of objects to an uninitialized area of memory
(niebloid)
ranges::uninitialized_fill
(C++20)
	copies an object to an uninitialized area of memory, defined by a range
(niebloid)
ranges::uninitialized_fill_n
(C++20)
	copies an object to an uninitialized area of memory, defined by a start and a count
(niebloid)
ranges::uninitialized_move
(C++20)
	moves a range of objects to an uninitialized area of memory
(niebloid)
ranges::uninitialized_move_n
(C++20)
	moves a number of objects to an uninitialized area of memory
(niebloid)
ranges::uninitialized_default_construct
(C++20)
	constructs objects by default-initialization in an uninitialized area of memory, defined by a range
(niebloid)
ranges::uninitialized_default_construct_n
(C++20)
	constructs objects by default-initialization in an uninitialized area of memory, defined by a start and count
(niebloid)
ranges::uninitialized_value_construct
(C++20)
	constructs objects by value-initialization in an uninitialized area of memory, defined by a range
(niebloid)
ranges::uninitialized_value_construct_n
(C++20)
	constructs objects by value-initialization in an uninitialized area of memory, defined by a start and a count
(niebloid)
ranges::destroy_at
(C++20)
	destroys an object at a given address
(niebloid)
ranges::destroy
(C++20)
	destroys a range of objects
(niebloid)
ranges::destroy_n
(C++20)
	destroys a number of objects in a range
(niebloid)
ranges::construct_at
(C++20)
	creates an object at a given address
(niebloid)
Garbage collector support (until C++23)
Defined in header <memory>
declare_reachable
(C++11)(removed in C++23)
	declares that an object can not be recycled
(function)
undeclare_reachable
(C++11)(removed in C++23)
	declares that an object can be recycled
(function template)
declare_no_pointers
(C++11)(removed in C++23)
	declares that a memory area does not contain traceable pointers
(function)
undeclare_no_pointers
(C++11)(removed in C++23)
	cancels the effect of std::declare_no_pointers
(function)
pointer_safety
(C++11)(removed in C++23)
	lists pointer safety models
(enum)
get_pointer_safety
(C++11)(removed in C++23)
	returns the current pointer safety model
(function)
Explicit lifetime management (since C++23)
Defined in header <memory>
start_lifetime_asstart_lifetime_as_array
(C++23)
	implicitly creates objects in given storage with the object representation reused
(function template)
Miscellaneous
Defined in header <memory>
pointer_traits
(C++11)
	provides information about pointer-like types
(class template)
to_address
(C++20)
	obtains a raw pointer from a pointer-like type
(function template)
addressof
(C++11)
	obtains actual address of an object, even if the & operator is overloaded
(function template)
align
(C++11)
	aligns a pointer in a buffer
(function)
assume_aligned
(C++20)
	informs the compiler that a pointer is aligned
(function template)
Low level memory management

Includes e.g. operator new, operator delete, std::set_new_handler
Defined in header <new>
C-style memory management

Includes e.g. std::malloc, std::free
Defined in header <cstdlib> 